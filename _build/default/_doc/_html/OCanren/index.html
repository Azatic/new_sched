<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (OCanren.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ OCanren</nav><header class="odoc-preamble"><h1 id="ocanren-"><a href="#ocanren-" class="anchor"></a>OCanren  <span class="version">%%VERSION%%</span></h1><p><code>OCanren</code> is a typed emebedding of relational programming languae into OCaml.</p></header><nav class="odoc-toc"><ul><li><a href="#note-on-types">Note on types</a></li><li><a href="#manuals">Resources</a></li></ul></nav><div class="odoc-content"><h2 id="note-on-types"><a href="#note-on-types" class="anchor"></a>Note on types</h2><p><code>OCanren</code> uses many types comparately to Scheme implementation. We are going to describe them shortly here.</p><p>Let's look at example of user-defined type: </p><pre class="language-ocaml"><code>type 'a list = Nil | Cons of 'a * 'a list </code></pre><p>It doesn't allow placing of logic variables instead of tail, we need to refactor it to allow that.</p><pre class="language-ocaml"><code>(** So called fully abstract type for list *)
type ('a,'b) glist = Nil | Cons of 'a * 'b</code></pre><p>With representation we can define (in presence of `-rectypes` compiler switch) the type isomorphic to original one, and the type with possibility to represent logic variables indide. The second one would be the result of our realtional queries.</p><pre class="language-ocaml"><code>type 'a list = ('a, 'a list) glist
type 'a list_logic = ('a, 'a list_logic) glist OCanren.logic</code></pre><p>In relational search we are using untyped representation of logic values with <a href="OCanren/index.html#type-ilogic"><code>OCanren.ilogic</code></a> type. We can construct this &quot;ilogic&quot; values using <a href="OCanren/index.html#val-inj"><code>OCanren.inj</code></a> function</p><pre class="language-ocaml"><code>let nil : unit -&gt;  ('a, 'b) glist illogic as 'b =
  fun () -&gt; OCanren.inj Nil
let cons : 'a ilogic -&gt; 'b -&gt; (('a ilogic, 'b) glist illogic as 'b) =
  fun h tl -&gt; OCanren.inj (Cons (h, tl))</code></pre><p>With this representation, empowered by relational constructions for conjunction (<a href="OCanren/index.html#val-(&amp;&amp;&amp;)"><code>OCanren.(&amp;&amp;&amp;)</code></a>), disjunction (<a href="OCanren/index.html#val-conde"><code>OCanren.conde</code></a>), unification (<a href="OCanren/index.html#val-(===)"><code>OCanren.(===)</code></a>) and for creating fresh variables (<a href="OCanren/Fresh/index.html"><code>OCanren.Fresh</code></a>) we can define a realtion to append relational lists. (In practice, relational lists are part of OCanren standard library: <a href="OCanren/Std/List/index.html"><code>OCanren.Std.List</code></a>).</p><pre class="language-ocaml"><code>let rec appendo a b ab =
  conde
    [ ((a === nil ()) &amp;&amp;&amp; (b === ab))
    ; Fresh.three (fun h t ab' -&gt;
        (a === cons h t) &amp;&amp;&amp;
        (ab === cons h ab') &amp;&amp;&amp;
        (appendo t b ab'))
    ]</code></pre><p>The usage of <code>Fresh</code> module could be replaced by syntax extension <code>ppx_fresh</code>.</p><p>After running a realtion, the inner representation (with many <code>ilogic</code> types) of values could be converted (<i>reified</i>) to user-friendly values. We can convert either to 'ground' represenation using family of functions called 'prj_exn', or to logic representation (in our case, of type `'a list_logic`) using family of functions 'reify'.</p><p>Writing 'reify' and 'prj_exn' by hand is tedious. We could recommend using PPX syntax extension <code>ppx_distrib</code> to to that.</p><p>We are going to use <a href="Tester/index.html"><code>Tester</code></a> module to run and print our relation. We ask OCanren to find all possible lists in a variable q, such that concatenation of them with a list <code> [3;4] </code> would give a list <code> [1;2;3;4] </code>.</p><pre class="language-ocaml"><code>open Tester
let%expect_test &quot; &quot; =
  run_r (list_prj_exn arg_prj_exn) (string_of_list string_of_arg) 1
        q qh (&quot;description&quot;, (fun q -&gt;
          appendo
            q
            (cons !!3 (cons !!4 (nil ()))
            (cons !!1 (cons !!2 (cons !!3 (cons !!4 (nil ()))))
          ));
  [%expect {|
  description, 1 answer {
  q=[1; 2];
  }
  |}]</code></pre><h2 id="manuals"><a href="#manuals" class="anchor"></a>Resources</h2><ul><li>The <a href="https://pltools.github.io/OCanren/api">API documentation</a>, which you are reading now.</li><li>The <a href="https://OCanren.readthedocs.io/">Handwritten documentation</a>, on Read The Docs webside.</li><li>The <a href="https://github.com/Kakadu/OCanren-basic-template">OCanren project template</a> which is recommended to use for quick start.</li></ul><ul class="modules"><li><a href="OCanren/index.html"><code>OCanren</code></a> </li></ul><ul class="modules"><li><a href="Install_timer/index.html"><code>Install_timer</code></a> <span class="synopsis">This package after its loading adds timer object to all OCanren modules. It's split to separate package to avoid hard dependency on <code>Mtime</code> package.</span></li></ul><ul class="modules"><li><a href="Pa_ocanren/index.html"><code>Pa_ocanren</code></a> </li></ul><ul class="modules"><li><a href="Tester/index.html"><code>Tester</code></a> </li></ul></div></body></html>